#include "scheduler.h"

// Scheduler implemented with PIT

// int terminal_idx = 0;       // variable used to keep track of next terminal that should be active


/*
 * init_pit()
 *   DESCRIPTION: Initializes the pit
 *   INPUTS: none
 *   OUTPUTS: none
 *   RETURN VALUE: void
 *   SIDE EFFECTS: Enables IRQ0
 */
void init_pit(){
    cli();
    int32_t freq = PIT_FREQ / 100;                  // divide by 100 to set interrupt to every 10 ms 

    outb(PIT_MODE3, PIT_MODE_P);                    // set pit mode to square wave generator
    outb(freq & LOW_MASK, PIT_DATA_P);              // set frequency to about 100 Hz for 10ms checks 
    outb((freq) >> 8, PIT_DATA_P);

    enable_irq(PIT_IRQ);                            // enable IRQ0 for PIT 
    sti();
}

/*
 * pit_handler()
 *   DESCRIPTION: Handles interrupt generated by PIT
 *   INPUTS: none
 *   OUTPUTS: none
 *   RETURN VALUE: void
 *   SIDE EFFECTS: Executes scheduler
 */
void pit_handler(){
    cli();                // Disable interrupts
    send_eoi(PIT_IRQ);    // Send EOI before calling scheduler
    scheduler();
    sti();                // Enable interrupts
}

/*
 * scheduler()
 *   DESCRIPTION: Switches to another process
 *   INPUTS: none
 *   OUTPUTS: none
 *   RETURN VALUE: void
 *   SIDE EFFECTS: 

● Update TA to track the internal state of the active terminal.                      --DONE
● We need to save ebp as we did for CP3 context switch.                              --DONE
● Update ESP0 in the TSS.                                                            --DONE
● Update page tables for the user program’s memory addresses (Do we need             --NOT DONE
to flush TLB?).
● Initiate context switch by restoring the ebp of the next terminal that should be   --DONE
active after the current one, since round robin this is just (TA = (TA + 1) % 3)

 */
void scheduler(){

    // pcb_t* cur_pcb = get_pcb(current_pid);      // Is getting PCBs necessary for scheduler?
    // pcb_t* next_pcb = get_pcb(current_pid);

    // Save current ebp and esp so that we can return to it
    /*uint32_t save_ebp, save_esp;
    asm volatile ("movl %%ebp, %0" : "=r" (save_ebp) );
    asm volatile ("movl %%esp, %0" : "=r" (save_esp) );
    
    int terminal_idx = cur_term;       // terminal_idx is now equal to the terminal that was just previously restored

    terminal[terminal_idx].saved_ebp = save_ebp;        // Save previous ebp and esp
    terminal[terminal_idx].saved_esp = save_esp;


    // Terminal goes from 0, 1, 2 and then back to 0. Next terminal that should be active
    // terminal_idx represents the next terminal that should be active
    cur_term = (cur_term + 1) % MAX_TERMINALS;        // Update TA to track the internal state of the active terminal
    

    tss.ss0 = KERNEL_DS;
    tss.esp0 = EIGHTMB - (EIGHTKB * (current_pid)) - FOURB;    // not sure if right (idk if its supposed to be current_pid here)

    

    asm volatile(
        "movl %0, %%ebp \n"                 // Move the saved_ebp of the new TA that was saved during its previous time slice into the EBP register
        "movl %1, %%esp \n"                 // So restoring ebp of next terminal that should be active, aka terminal_idx
        "leave          \n"                 // Restore frame as normal (Leave, ret).
        "ret            \n"
        :
        : "r"(terminal[cur_term].saved_ebp), "r"(terminal[cur_term].saved_esp)      // Restore next terminal's state   
        : "memory"                                                                 
    );*/

}



